# マイグレーションガイド

**Date**: 2025-11-05 18:40
**Document Type**: Migration Guide
**Priority**: Critical
**Related Documents**:
- `01-BUG_ANALYSIS.md` (問題分析)
- `03-IMPLEMENTATION_PLAN.md` (実装計画)
- `04-TEST_STRATEGY.md` (テスト計画)

---

## 📋 目次

1. [エグゼクティブサマリー](#エグゼクティブサマリー)
2. [既存データへの影響分析](#既存データへの影響分析)
3. [マイグレーション不要の根拠](#マイグレーション不要の根拠)
4. [デプロイ計画](#デプロイ計画)
5. [リスク評価](#リスク評価)
6. [ロールバック計画](#ロールバック計画)
7. [リリースチェックリスト](#リリースチェックリスト)

---

## エグゼクティブサマリー

### 変更概要

**Phase 1: エッジケース修正**
- 0点（score === 0）の扱いを「未入力」から「正常データ」に変更
- 集計ロジックの条件分岐を修正（4箇所）

**Phase 2: selectedUserId対応**
- revenueStats/chipStatsをselectedUserIdベースに書き換え
- 半荘単位での動的計算に変更

### データマイグレーション

**結論**: 不要

**理由**:
- データベーススキーマ変更なし
- 既存データの構造変更なし
- 計算ロジックのみの変更

### デプロイ影響

**ダウンタイム**: なし

**互換性**: 完全な後方互換性

**リスク**: 低（計算ロジックの変更のみ）

---

## 既存データへの影響分析

### データベーススキーマ

#### 変更なし

**影響を受けるテーブル**: なし

**理由**:
- `PlayerResult`の型定義変更なし
- `Session`の型定義変更なし
- `SessionSummary`の型定義変更なし

**確認済み**:
```typescript
// db.ts: Line 72-84（変更なし）
export interface PlayerResult {
  id: string
  hanchanId: string
  playerName: string
  userId: string | null
  score: number  // ✅ 型定義変更なし（number）
  umaMark: UmaMark
  chips: number
  parlorFee: number
  isSpectator: boolean  // ✅ 型定義変更なし
  position: number
}
```

### 既存データの再計算

#### Phase 1: エッジケース修正

**影響を受けるデータ**:
- 0点（score === 0）を含むセッション

**影響内容**:
- これまで除外されていた0点半荘が統計に含まれるようになる
- `SessionSummary`の再計算が必要（自動的に行われる）

**自動再計算のタイミング**:
```typescript
// Phase 1修正により、以下のタイミングで自動的に正しい統計が表示される:

1. 分析タブ表示時（useMemoで動的計算）
   → 即座に修正後のロジックで計算

2. 新規セッション保存時（saveSessionWithSummary）
   → 修正後のcalculateSessionSummaryで計算

3. 既存セッション参照時
   → session.summaryは古いデータだが、分析タブでは使用しない（Phase 2で対応）
```

**既存session.summaryの扱い**:
- 履歴タブ: 既存のsession.summaryを使用（影響なし）
- 分析タブ: session.summaryを使用しない（Phase 2で動的計算）

**結論**: 既存データの手動再計算は不要

#### Phase 2: selectedUserId対応

**影響を受けるデータ**: なし

**理由**:
- 既存データの構造変更なし
- 計算方法の変更のみ
- 動的計算なので既存データに影響なし

**確認**:
```typescript
// 修正前: session.summary使用
filteredSessions.forEach(({ session }) => {
  if (session.summary) {
    const totalPayout = session.summary.totalPayout
    // ... 既存データの参照のみ
  }
})

// 修正後: 半荘単位で動的計算
filteredSessions.forEach(({ session, hanchans }) => {
  if (hanchans) {
    hanchans.forEach(hanchan => {
      // ... 半荘データから計算
    })
  }
})
```

**結論**: 既存データの変更なし、再計算不要

---

## マイグレーション不要の根拠

### 1. スキーマ変更なし

**確認項目**:
- [ ] テーブル定義変更なし
- [ ] カラム追加/削除なし
- [ ] 型定義変更なし
- [ ] インデックス変更なし

**証拠**:
```typescript
// db.ts: すべてのinterface定義が変更なし
export interface PlayerResult { ... }  // 変更なし
export interface Session { ... }       // 変更なし
export interface SessionSummary { ... } // 変更なし
```

### 2. 既存データの互換性

**確認項目**:
- [ ] 既存データが新しいロジックで読み取り可能
- [ ] データの構造変更なし
- [ ] 外部キー制約への影響なし

**証拠**:
- Phase 1: 条件分岐の変更のみ、データ構造に影響なし
- Phase 2: 計算方法の変更のみ、データ構造に影響なし

### 3. 動的計算による自動適用

**Phase 1の自動適用**:
```typescript
// calculateSessionSummary: 修正後のロジックで自動計算
if (mainUserResult.score === null) {  // ✅ 0点を除外しない
  continue
}
```

**Phase 2の自動適用**:
```typescript
// AnalysisTab: selectedUserIdで動的計算
const revenueStats = useMemo(() => {
  // ✅ 既存データから動的に計算
  filteredSessions.forEach(({ session, hanchans }) => { ... })
}, [filteredSessions, selectedUserId])
```

**結論**: コードデプロイと同時に新しいロジックが適用される

### 4. session.summaryの扱い

**既存のsession.summary**:
- 保存時に計算された古いデータ（0点を除外）
- mainUser専用のデータ

**新しいロジック**:
- 分析タブ: session.summaryを使用しない（Phase 2で動的計算）
- 履歴タブ: 既存のsession.summaryを使用（影響なし）

**再計算のタイミング**:
- 新規セッション保存時: 自動的に新しいロジックで計算
- 既存セッション: 再保存するまで古いsession.summary（履歴タブのみ使用）

**影響範囲**:
```
分析タブ:
  ✅ 即座に新しいロジックが適用（動的計算）

履歴タブ:
  ⚠️ 既存セッションは古いsession.summaryを表示
  → 実害なし（mainUserの統計は正しい）
  → 新規保存で自動的に更新
```

**結論**: 実用上、マイグレーション不要

---

## デプロイ計画

### デプロイ戦略

**方式**: Blue-Green Deployment（推奨）

**理由**:
- ロールバックが容易
- ダウンタイムなし
- リスクが低い

### デプロイ手順

#### 事前準備

1. **コードレビュー完了確認**
   - [ ] Phase 1の全修正箇所をレビュー
   - [ ] Phase 2の全修正箇所をレビュー
   - [ ] エッジケース判定の一貫性を確認

2. **テスト完了確認**
   - [ ] Phase 1テスト完了（EDGE-001〜004）
   - [ ] Phase 2テスト完了（USERID-001〜003）
   - [ ] 回帰テスト完了（REGRESS-001〜003）

3. **バックアップ作成**
   ```bash
   # IndexedDBのエクスポート（開発者ツールから）
   # または、既存データのJSON export機能を使用
   ```

4. **リリースノート作成**
   - Phase 1: 0点の扱い修正
   - Phase 2: ユーザー切り替え機能改善

#### デプロイ実行

**Phase 1デプロイ**:

1. **ビルド実行**
   ```bash
   cd /Users/nishimototakashi/claude_code/mj_app/app
   npm run build
   ```

2. **本番環境デプロイ**
   ```bash
   # デプロイコマンド（環境により異なる）
   npm run deploy
   ```

3. **即座に動作確認**
   - [ ] トップページ表示
   - [ ] 新規セッション作成
   - [ ] 0点半荘を含むセッション保存
   - [ ] 履歴タブ表示

4. **Phase 1テスト実施**（10分）
   - [ ] EDGE-001: 単一セッション・0点半荘
   - [ ] REGRESS-001: 履歴タブ表示

5. **問題なければPhase 2へ進む**

**Phase 2デプロイ**:

1. **Phase 1が正常動作していることを確認**
   - [ ] エラーログなし
   - [ ] ユーザーからの問題報告なし

2. **ビルド実行**
   ```bash
   npm run build
   ```

3. **本番環境デプロイ**
   ```bash
   npm run deploy
   ```

4. **即座に動作確認**
   - [ ] 分析タブ表示
   - [ ] ユーザーフィルター切り替え
   - [ ] 統計が更新される

5. **Phase 2テスト実施**（15分）
   - [ ] USERID-001: ユーザー切り替え基本動作
   - [ ] REGRESS-003: 分析タブ基本機能

#### デプロイ後確認

1. **エラーログ監視**（24時間）
   - ブラウザコンソールエラー
   - アプリケーションエラー

2. **パフォーマンス監視**
   - 分析タブの表示速度
   - ユーザー切り替えの応答速度

3. **ユーザーフィードバック収集**
   - 問題報告の有無
   - 統計の正確性に関する問い合わせ

### デプロイスケジュール

**推奨タイミング**: 平日午前（ユーザー影響が少ない時間帯）

**所要時間**:
- Phase 1デプロイ: 30分
- Phase 1監視: 1時間
- Phase 2デプロイ: 30分
- Phase 2監視: 1時間

**合計**: 3時間

---

## リスク評価

### Phase 1: エッジケース修正

#### リスク1: 既存統計の変動

**内容**: 0点半荘が統計に含まれることで、既存の統計値が変わる

**発生確率**: 🟢 低（0点半荘は少数）

**影響度**: 🟡 中（統計が変わる）

**対策**:
- リリースノートで説明
- 「0点半荘が正しく集計されるようになりました」と明記

**ユーザー影響**:
- 統計が「より正確」になる
- 履歴タブの半荘数が増える可能性（0点半荘が含まれる）

#### リスク2: 計算ロジックのバグ

**内容**: 条件分岐の修正でバグが混入

**発生確率**: 🟢 極めて低（単純な条件削除のみ）

**影響度**: 🔴 高（統計が不正確になる）

**対策**:
- 徹底したテスト（EDGE-001〜004）
- コードレビュー
- 即座のロールバック準備

**検出方法**:
- テストケースで検出
- ユーザーからの問題報告

### Phase 2: selectedUserId対応

#### リスク3: パフォーマンス低下

**内容**: 半荘単位での計算により、統計表示が遅くなる

**発生確率**: 🟢 極めて低（useMemoでキャッシュ）

**影響度**: 🟡 中（ユーザー体験に影響）

**対策**:
- パフォーマンステスト実施（PERF-001）
- useMemoの依存配列を正しく設定

**許容範囲**:
- 初回表示: 50ms以下
- ユーザー切り替え: 50ms以下

#### リスク4: chips/parlorFeeの二重カウント

**内容**: chips/parlorFeeが複数回カウントされる

**発生確率**: 🟡 低（実装パターン確立済み）

**影響度**: 🔴 高（統計が不正確になる）

**対策**:
- セッション単位の1回のみカウントロジックを徹底
- テストケースで検証（USERID-002）

**検出方法**:
- 統合テストで検出
- 手動計算との比較

#### リスク5: selectedUserId依存配列の誤り

**内容**: 依存配列に`selectedUserId`が欠落し、統計が更新されない

**発生確率**: 🟢 極めて低（実装計画で明記）

**影響度**: 🔴 高（機能が動作しない）

**対策**:
- コードレビューで確認
- テストケースで検証（USERID-001）
- ESLintの警告を確認

**検出方法**:
- ユーザー切り替えテストで即座に検出

### リスクマトリックス

| リスク | 発生確率 | 影響度 | 重大度 | 対策 |
|--------|---------|-------|--------|------|
| 既存統計の変動 | 🟢 低 | 🟡 中 | 🟡 Medium | リリースノート |
| 計算ロジックのバグ | 🟢 極めて低 | 🔴 高 | 🟡 Medium | テスト徹底 |
| パフォーマンス低下 | 🟢 極めて低 | 🟡 中 | 🟢 Low | パフォーマンステスト |
| chips二重カウント | 🟡 低 | 🔴 高 | 🟡 Medium | テストケース |
| 依存配列の誤り | 🟢 極めて低 | 🔴 高 | 🟡 Medium | コードレビュー |

**総合リスク評価**: 🟡 Medium（管理可能）

---

## ロールバック計画

### ロールバック判断基準

**即座のロールバック**（重大な問題）:
- [ ] アプリが起動しない
- [ ] 統計が完全に誤っている（計算エラー）
- [ ] パフォーマンスが著しく低下（3秒以上）

**段階的ロールバック**（軽微な問題）:
- [ ] 特定のエッジケースで誤動作
- [ ] UIの表示がおかしい
- [ ] 一部の統計が不正確

**ロールバック不要**（許容範囲）:
- [ ] 統計値が以前と異なる（正確になった）
- [ ] パフォーマンスがわずかに低下（50ms以下）

### ロールバック手順

#### Phase 1ロールバック

**前提**: Phase 1デプロイ後に問題が発生

**手順**:
1. **Git revert実行**
   ```bash
   cd /Users/nishimototakashi/claude_code/mj_app
   git revert <Phase 1 commit hash>
   git push
   ```

2. **ビルド・デプロイ**
   ```bash
   cd app
   npm run build
   npm run deploy
   ```

3. **動作確認**
   - [ ] トップページ表示
   - [ ] 既存セッション表示
   - [ ] 新規セッション作成

**所要時間**: 15分

#### Phase 2ロールバック

**前提**: Phase 2デプロイ後に問題が発生

**手順**:
1. **Git revert実行**（Phase 2のみ）
   ```bash
   git revert <Phase 2 commit hash>
   git push
   ```

2. **Phase 1は維持**（問題がなければ）

3. **ビルド・デプロイ**
   ```bash
   npm run build
   npm run deploy
   ```

4. **動作確認**
   - [ ] Phase 1の機能が正常
   - [ ] 分析タブが表示される（session.summary使用に戻る）

**所要時間**: 15分

#### 完全ロールバック

**前提**: Phase 1とPhase 2の両方に問題がある

**手順**:
1. **Git revert実行**（両方のcommit）
   ```bash
   git revert <Phase 2 commit hash>
   git revert <Phase 1 commit hash>
   git push
   ```

2. **ビルド・デプロイ**

3. **完全に元の状態に戻る**

**所要時間**: 20分

### ロールバック後の対応

1. **原因分析**
   - エラーログの確認
   - テストケースの再実行
   - コードレビュー

2. **修正計画**
   - バグ修正
   - 追加テスト
   - 再デプロイ計画

3. **ユーザーへの連絡**
   - 問題の説明
   - 対応状況の報告
   - 再デプロイの予定

---

## リリースチェックリスト

### Phase 1: デプロイ前

**コード準備**:
- [ ] session-utils.ts: Line 142修正済み
- [ ] session-utils.ts: Line 203修正済み
- [ ] InputTab.tsx: Line 260修正済み
- [ ] AnalysisTab.tsx: Line 135修正済み
- [ ] コメントが正確
- [ ] コードレビュー完了

**テスト完了**:
- [ ] EDGE-001: 単一セッション・0点半荘
- [ ] EDGE-002: 複数半荘・0点を含む
- [ ] EDGE-004: 0点と未入力の違い
- [ ] REGRESS-001: 履歴タブ表示

**ドキュメント準備**:
- [ ] リリースノート作成
- [ ] ユーザー向け説明準備

### Phase 1: デプロイ実施

**ビルド・デプロイ**:
- [ ] ビルドエラーなし
- [ ] デプロイ成功
- [ ] 本番環境で起動確認

**即座の動作確認**:
- [ ] トップページ表示
- [ ] 新規セッション作成
- [ ] 0点半荘保存
- [ ] 履歴タブ表示

**テスト実施**:
- [ ] EDGE-001: 本番環境で実施
- [ ] REGRESS-001: 本番環境で実施

### Phase 1: デプロイ後監視

**エラー監視**（1時間）:
- [ ] ブラウザコンソールエラーなし
- [ ] アプリケーションエラーなし
- [ ] ユーザーからの問題報告なし

**Phase 2へ進む判断**:
- [ ] Phase 1が正常動作
- [ ] 重大な問題なし
- [ ] ロールバック不要

### Phase 2: デプロイ前

**コード準備**:
- [ ] AnalysisTab.tsx: revenueStats修正済み
- [ ] AnalysisTab.tsx: chipStats修正済み
- [ ] 依存配列に`selectedUserId`追加
- [ ] chips/parlorFee 1回のみカウントロジック実装
- [ ] コードレビュー完了

**テスト完了**:
- [ ] USERID-001: ユーザー切り替え基本動作
- [ ] USERID-002: 複数セッション・chips/parlorFee
- [ ] REGRESS-003: 分析タブ基本機能

### Phase 2: デプロイ実施

**ビルド・デプロイ**:
- [ ] ビルドエラーなし
- [ ] デプロイ成功
- [ ] 本番環境で起動確認

**即座の動作確認**:
- [ ] 分析タブ表示
- [ ] ユーザーフィルター切り替え
- [ ] 統計が更新される

**テスト実施**:
- [ ] USERID-001: 本番環境で実施
- [ ] REGRESS-003: 本番環境で実施

### Phase 2: デプロイ後監視

**エラー監視**（1時間）:
- [ ] ブラウザコンソールエラーなし
- [ ] アプリケーションエラーなし
- [ ] ユーザーからの問題報告なし

**パフォーマンス確認**:
- [ ] 分析タブの表示速度: 50ms以下
- [ ] ユーザー切り替えの応答速度: 50ms以下

**機能確認**:
- [ ] ユーザー切り替えで統計が更新される
- [ ] chips/parlorFeeが正しくカウントされる

### 最終確認

**24時間後**:
- [ ] エラーログなし
- [ ] パフォーマンス問題なし
- [ ] ユーザーからの問題報告なし

**1週間後**:
- [ ] 統計の正確性に問題なし
- [ ] ユーザー満足度が向上

**完了宣言**:
- [ ] すべてのチェック項目完了
- [ ] ドキュメント更新
- [ ] プロジェクトクローズ

---

## まとめ

### デプロイの安全性

**Phase 1**: 🟢 非常に安全
- データ変更なし
- 計算ロジックの単純な修正
- ロールバックが容易

**Phase 2**: 🟡 安全（注意が必要）
- 統計計算の完全書き換え
- パフォーマンステスト必須
- ロールバック準備が重要

### 推奨アプローチ

1. **Phase 1を先行デプロイ**
   - リスクが低い
   - Phase 2の基盤となる

2. **Phase 1の安定を確認**
   - 1時間以上の監視
   - 問題がないことを確認

3. **Phase 2をデプロイ**
   - Phase 1が正常動作していることが前提
   - 徹底したテスト

4. **継続的な監視**
   - 24時間のエラー監視
   - 1週間のパフォーマンス監視

### 成功の鍵

- **徹底したテスト**: すべてのテストケースを実施
- **段階的なデプロイ**: Phase 1 → Phase 2の順守
- **迅速なロールバック**: 問題発生時の即座の対応
- **継続的な監視**: デプロイ後の注意深い観察

---

**Document Version**: 1.0
**Last Updated**: 2025-11-05 18:40
**Status**: Ready for Deployment
