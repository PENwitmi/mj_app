# ユーザー参加フィルタリングバグ修正

**作成日**: 2025-10-10
**Phase**: Phase 5 - 分析タブバグ修正
**重要度**: 🔴 Critical（データ整合性に影響）

---

## 問題の概要

分析タブにおいて、登録ユーザーを選択した際、**そのユーザーが参加していないセッション/半荘のデータがグラフや統計に含まれてしまう**問題が発見された。

---

## 具体的な症状

### 症状1: 収支推移グラフ
- ユーザーAを選択
- ユーザーAが**参加していない日**のデータが0円として表示される
- 結果: グラフに意味のないデータポイント（0円）が含まれる

### 症状2: モードフィルター
- ユーザーBを選択し、「4人打ち」モードでフィルタリング
- ユーザーBが**4人打ちに1回も参加していない**場合でも、グラフが表示される
- 結果: 全て0円のグラフが表示される（誤解を招く）

### 症状3: 統計カード
- ユーザーCを選択
- ユーザーCが参加していないセッションも統計の分母に含まれる可能性
- 結果: 統計値が不正確

---

## 影響範囲

### 影響を受けるコンポーネント
1. **収支推移グラフ** (`RevenueTimelineChart.tsx`)
2. **着順統計グラフ** (`RankStatisticsChart.tsx`)
3. **統計カード** (`AnalysisTab.tsx`内)
   - 収支統計
   - ポイント統計
   - チップ統計
   - 着順統計

### 影響を受けないコンポーネント
- **フィルターUI** (`AnalysisFilters.tsx`) - 表示のみ
- **メインユーザー** - 全セッションに参加前提のため問題なし

---

## 原因分析

### 根本原因
`AnalysisTab.tsx`の`filteredSessions`作成時に、**ユーザーの参加状況をチェックしていない**。

**現在の実装**:
```typescript
const filteredSessions = useMemo(() => {
  let filtered = sessions
  filtered = filterSessionsByPeriod(filtered, selectedPeriod)
  filtered = filterSessionsByMode(filtered, selectedMode)
  return filtered  // ← ユーザー参加チェックがない
}, [sessions, selectedPeriod, selectedMode])
```

### データフロー
1. `useSessions()` → 全セッションを取得（メインユーザー基準）
2. `filterSessionsByPeriod()` → 期間でフィルタリング
3. `filterSessionsByMode()` → モードでフィルタリング
4. **❌ ユーザー参加フィルタリングがない**
5. `prepareTimelineData()` → 参加していない場合、`sessionRevenue = 0`
6. グラフにプロット → 0円として表示

### 具体例
**セッションA（2025-10-05）**:
- 半荘1: メインユーザー、ユーザーB、ユーザーC、ユーザーD（4人打ち）
- 半荘2: メインユーザー、ユーザーB、ユーザーC、ユーザーD（4人打ち）

**ユーザーEを選択した場合**:
- ユーザーEはセッションAに**参加していない**
- しかし、`filteredSessions`にセッションAが含まれる
- `prepareTimelineData()`で`sessionRevenue = 0`
- グラフに「2025-10-05: 0円」としてプロット ❌

---

## 解決策の検討

### 案1: データ準備段階でフィルタリング
**実装場所**: `RevenueTimelineChart.tsx`の`prepareTimelineData()`関数内

**メリット**:
- グラフコンポーネント内で完結
- 局所的な修正

**デメリット**:
- 着順統計グラフ、統計カードでも同じ問題が発生
- 各コンポーネントで同じロジックを実装（コード重複）
- DRY原則違反
- 保守性低下

---

### 案2: フィルター段階でフィルタリング ✅ **採用**
**実装場所**: `AnalysisTab.tsx`の`filteredSessions`作成部分

**メリット**:
1. **一箇所のフィルタリングで全コンポーネントに適用**
   - 収支推移グラフ
   - 着順統計グラフ
   - 統計カード（収支・ポイント・チップ・着順）
2. **直感的な処理フロー**:
   - 期間フィルター → モードフィルター → **参加フィルター** → 計算・表示
3. **単一責任の原則**: フィルタリングはフィルタリング、計算は計算と分離
4. **保守性**: 「参加」の定義変更時も1箇所の修正で済む
5. **パフォーマンス**: 早い段階でデータを絞るため、以降の計算が軽量化
6. **一貫性**: 全ての統計・グラフで同じ基準が適用される

**デメリット**:
- なし（意図した動作のため）

---

## 実装手順（4ステップ）

### Step 1: コード修正
**所要時間**: 5分
**場所**: `src/components/tabs/AnalysisTab.tsx` 43-48行目

**変更前**:
```typescript
const filteredSessions = useMemo(() => {
  let filtered = sessions
  filtered = filterSessionsByPeriod(filtered, selectedPeriod)
  filtered = filterSessionsByMode(filtered, selectedMode)
  return filtered
}, [sessions, selectedPeriod, selectedMode])
```

**変更後**:
```typescript
const filteredSessions = useMemo(() => {
  let filtered = sessions
  filtered = filterSessionsByPeriod(filtered, selectedPeriod)
  filtered = filterSessionsByMode(filtered, selectedMode)

  // 選択ユーザーが参加しているセッションのみに絞る
  filtered = filtered.filter(({ hanchans }) => {
    if (!hanchans) return false

    // 半荘内の少なくとも1つに、選択ユーザーが参加していればOK
    return hanchans.some(hanchan =>
      hanchan.players.some(p =>
        p.userId === selectedUserId && !p.isSpectator
      )
    )
  })

  return filtered
}, [sessions, selectedPeriod, selectedMode, selectedUserId])
```

**変更内容**:
1. フィルタリングロジックを追加（11行）
2. 依存配列に`selectedUserId`を追加

---

### Step 2: TypeScript型チェック・Lint
**所要時間**: 3分

```bash
# TypeScript型チェック
npm run build

# Lint実行
npm run lint
```

**期待される結果**:
- ✅ ビルドエラーなし
- ✅ 型エラーなし
- ✅ Lint警告なし

---

### Step 3: 開発サーバー起動
**所要時間**: 1分

```bash
npm run dev
```

**確認事項**:
- ✅ サーバーが正常起動（ポート5173）
- ✅ コンソールエラーなし

---

### Step 4: ブラウザ動作確認
**所要時間**: 10-15分

詳細は「実装後の検証手順」セクションを参照。

---

## 参加の定義

**「参加している」の定義**:
- セッション内の**少なくとも1半荘**に参加していること
- **見学者を除く** (`!p.isSpectator`)
- `p.userId === selectedUserId`でユーザーIDが一致

**判定ロジック**:
```typescript
hanchans.some(hanchan =>           // 半荘の中で少なくとも1つ
  hanchan.players.some(p =>        // プレイヤーの中で少なくとも1人
    p.userId === selectedUserId    // 選択ユーザーIDが一致
    && !p.isSpectator              // かつ、見学者でない
  )
)
```

---

## エッジケース

実装時に考慮すべきエッジケースとその対応方法。

### エッジケース1: hanchansがundefined
**状況**: セッションデータが不完全（hanchansプロパティが存在しない）

**データ例**:
```typescript
{ session: {...}, hanchans: undefined }
```

**対応**:
```typescript
if (!hanchans) return false  // セッションを除外
```

**結果**: ✅ 正しく除外される

---

### エッジケース2: 空の半荘配列
**状況**: セッションに半荘データが1つもない

**データ例**:
```typescript
{ session: {...}, hanchans: [] }
```

**対応**:
```typescript
hanchans.some(...)  // 空配列の場合、some()はfalseを返す
```

**結果**: ✅ 正しく除外される

---

### エッジケース3: 全員見学者の半荘
**状況**: 半荘内の全プレイヤーが見学者

**データ例**:
```typescript
hanchans: [{
  players: [
    { userId: 'user-A', isSpectator: true },
    { userId: 'user-B', isSpectator: true }
  ]
}]
```

**対応**:
```typescript
p.userId === selectedUserId && !p.isSpectator  // 見学者は除外
```

**結果**: ✅ 正しく除外される

---

### エッジケース4: 半荘内で一部参加・一部見学
**状況**: セッション内の半荘1で参加、半荘2で見学

**データ例**:
```typescript
hanchans: [
  { players: [{ userId: 'user-A', isSpectator: false }] },  // 参加
  { players: [{ userId: 'user-A', isSpectator: true }] }    // 見学
]
```

**対応**:
```typescript
hanchans.some(...)  // 少なくとも1半荘で参加していればtrue
```

**結果**: ✅ セッションに含まれる（正しい動作）

---

### エッジケース5: playersが空配列
**状況**: 半荘にプレイヤーデータが存在しない（データ不整合）

**データ例**:
```typescript
hanchans: [{ players: [] }]
```

**対応**:
```typescript
hanchan.players.some(...)  // 空配列の場合、some()はfalseを返す
```

**結果**: ✅ 正しく除外される

---

## 期待される動作

### 修正後の動作

#### ケース1: ユーザーが一部のセッションに参加
**データ**:
- セッションA（2025-10-05）: ユーザーB参加 ✅
- セッションB（2025-10-06）: ユーザーB不参加 ❌
- セッションC（2025-10-07）: ユーザーB参加 ✅

**ユーザーB選択時**:
- グラフ: セッションAとCのみプロット
- 統計: セッションAとCのみ集計

#### ケース2: ユーザーがモードに参加していない
**データ**:
- 4人打ちセッション10件: ユーザーC不参加
- 3人打ちセッション5件: ユーザーC参加

**ユーザーC選択 + 4人打ちモード**:
- フィルタリング結果: 0件
- グラフ: データなしメッセージ表示
- 統計カード: データなしメッセージ表示

#### ケース3: メインユーザー
**動作**: 変更なし（全セッションに参加前提）

---

## 実装後の検証手順（詳細）

### 前提: テストデータ準備
以下のテストデータを用意する（既存データまたは新規作成）:

**セッションデータ**:
- セッション1（2025-10-01）: メインユーザー、ユーザーB、ユーザーC（4人打ち）
- セッション2（2025-10-02）: メインユーザー、ユーザーB、ユーザーD（4人打ち）
- セッション3（2025-10-03）: メインユーザー、ユーザーC、ユーザーD（3人打ち）
- セッション4（2025-10-04）: メインユーザー、ユーザーB（見学）、ユーザーC（3人打ち）
- セッション5（2025-10-05）: メインユーザー、ユーザーC、ユーザーD（4人打ち）

---

### 検証1: 参加フィルタリングの基本動作
**所要時間**: 3分

**手順**:
1. 開発サーバー起動: `npm run dev`
2. ブラウザで `http://localhost:5173` を開く
3. 分析タブを選択
4. ユーザー選択で「ユーザーB」を選択
5. 期間を「全期間」に設定
6. モードを「全体」に設定

**期待される結果**:
- ✅ 収支推移グラフ: セッション1、2のみプロット（3件ではない）
- ✅ セッション4は除外される（見学者）
- ✅ 統計カード: 2セッション分の統計のみ

---

### 検証2: 全不参加のモード
**所要時間**: 2分

**手順**:
1. ユーザー選択で「ユーザーD」を選択
2. モードを「3人打ち」に設定

**期待される結果**:
- ✅ グラフエリア: 「データがありません」メッセージ表示
- ✅ 着順統計グラフ: 非表示または「データがありません」
- ✅ 統計カード: 表示されるが、全て0

---

### 検証3: 一部参加
**所要時間**: 3分

**手順**:
1. ユーザー選択で「ユーザーC」を選択
2. モードを「4人打ち」に設定
3. 期間を「全期間」に設定

**期待される結果**:
- ✅ 収支推移グラフ: セッション1、5のみプロット（2データポイント）
- ✅ セッション3、4は除外される（3人打ちまたは見学）
- ✅ 着順統計グラフ: 2半荘分の統計

---

### 検証4: 見学者は除外
**所要時間**: 2分

**手順**:
1. ユーザー選択で「ユーザーB」を選択
2. モードを「3人打ち」に設定
3. 期間を「全期間」に設定

**期待される結果**:
- ✅ グラフエリア: 「データがありません」メッセージ
- ✅ セッション4は除外される（見学者として参加）

---

### 検証5: メインユーザーは影響なし
**所要時間**: 2分

**手順**:
1. ユーザー選択で「自分」を選択
2. モードを「全体」に設定
3. 期間を「全期間」に設定

**期待される結果**:
- ✅ 全セッション表示（5セッション）
- ✅ 修正前と同じ動作

---

### 検証6: フィルター組み合わせ
**所要時間**: 3分

**手順**:
1. ユーザー選択で「ユーザーC」を選択
2. 期間を「今月」に設定
3. モードを「4人打ち」に設定
4. 各フィルターを変更しながら動作確認

**期待される結果**:
- ✅ 期間フィルター変更時: グラフが正しく更新される
- ✅ モードフィルター変更時: グラフが正しく更新される
- ✅ ユーザー切り替え時: グラフが正しく更新される
- ✅ コンソールエラーなし

---

### 検証7: コンソールエラー確認
**所要時間**: 1分

**手順**:
1. ブラウザDevTools（F12）を開く
2. Consoleタブを確認
3. 上記検証1-6を実施中のエラーをチェック

**期待される結果**:
- ✅ エラーメッセージなし
- ✅ 警告メッセージなし
- ⚠️ もし警告があれば内容を記録

---

## 影響の確認

### 修正後に確認すべき項目

#### 1. 収支推移グラフ
- [ ] 参加していない日が表示されない
- [ ] 累積収支グラフも正しく動作

#### 2. 着順統計グラフ
- [ ] 参加していないモードでデータなしメッセージ
- [ ] 着順分布が正しく表示

#### 3. 統計カード
- [ ] 収支統計が正確
- [ ] ポイント統計が正確
- [ ] チップ統計が正確
- [ ] 着順統計が正確（totalGamesが正しい）

#### 4. フィルター動作
- [ ] 期間フィルターとの組み合わせ
- [ ] モードフィルターとの組み合わせ
- [ ] ユーザー切り替え時の動作

---

## 関連ファイル

### 修正対象
- `src/components/tabs/AnalysisTab.tsx`（約50行目）

### 影響を受けるが修正不要
- `src/components/analysis/RevenueTimelineChart.tsx`
- `src/components/analysis/RankStatisticsChart.tsx`
- `src/lib/db/analysis.ts`

### テスト関連
- 既存のPlaywright E2Eテストは影響なし（分析タブのテストはまだ未実装）

---

## 備考

### データ整合性の重要性
このバグは**データの正確性に直接影響する**重大な問題。統計分析の信頼性を損なうため、優先的に修正する必要がある。

### 後方互換性
この修正は、既存の動作を**意図的に変更する**ものであり、後方互換性はない。ただし、元の動作自体がバグであるため、これは正当な変更。

### Phase 5の完成度
この修正により、Phase 5（分析タブ）の基本機能が完成する。

---

**次のステップ**: 実装 → テスト → 動作確認
