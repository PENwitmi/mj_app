import { db, type User, type Session, type Hanchan, type PlayerResult, type UmaMark, type GameMode } from './db';
import { logger } from './logger';
import { DatabaseError, ValidationError, NotFoundError } from './errors';
import { umaMarkToValue } from './uma-utils';
import type { SessionSettings } from '@/components/input/SessionSettings';

// ========================================
// UI Layer Types (編集用)
// ========================================

/**
 * UI層で使用する半荘データ型
 * DB層のHanchanとの違い:
 * - idを含まない（編集時は新規作成されるため）
 * - players配列がUIPlayerResult型
 */
export interface UIHanchan {
  hanchanNumber: number
  players: UIPlayerResult[]
  autoCalculated: boolean
}

/**
 * UI層で使用するプレイヤー結果型
 * DB層のPlayerResultとの違い:
 * - idとhanchanIdを含まない
 * - umaMarkManualフィールドを含む（UI専用）
 */
export interface UIPlayerResult {
  playerName: string
  userId: string | null
  score: number | null
  umaMark: UmaMark
  chips: number
  parlorFee: number
  isSpectator: boolean
  umaMarkManual: boolean  // UI専用: ウママークが手動設定されたか
}

// ========================================
// Analysis Types (Phase 5: 分析タブ用)
// ========================================

/**
 * 期間フィルタータイプ
 */
export type PeriodType =
  | 'this-month'      // 今月
  | 'this-year'       // 今年
  | `year-${number}`  // 特定年（例: 'year-2024'）
  | 'all-time'        // 全期間

/**
 * 分析フィルター条件
 */
export interface AnalysisFilter {
  userId: string           // 分析対象ユーザーID
  period: PeriodType       // 期間フィルター
  mode: GameMode | 'all'   // モードフィルター（'4-player' | '3-player' | 'all'）
}

/**
 * 着順統計
 */
export interface RankStatistics {
  totalGames: number         // 総半荘数
  rankCounts: {
    first: number            // 1位回数
    second: number           // 2位回数
    third: number            // 3位回数
    fourth?: number          // 4位回数（4人打ちのみ）
  }
  rankRates: {
    first: number            // 1位率（%）
    second: number           // 2位率（%）
    third: number            // 3位率（%）
    fourth?: number          // 4位率（%）
  }
  averageRank: number        // 平均着順（小数第2位まで）
}

/**
 * 収支統計
 */
export interface RevenueStatistics {
  totalIncome: number        // 総収入（プラスセッションの合計）
  totalExpense: number       // 総支出（マイナスセッションの合計、負の値）
  totalBalance: number       // 総収支（totalIncome + totalExpense）
}

/**
 * ポイント統計
 */
export interface PointStatistics {
  plusPoints: number         // プラスポイント合計（半荘単位）
  minusPoints: number        // マイナスポイント合計（半荘単位、負の値）
  pointBalance: number       // ポイント収支（plusPoints + minusPoints）
}

/**
 * チップ統計
 */
export interface ChipStatistics {
  plusChips: number          // プラスチップ合計
  minusChips: number         // マイナスチップ合計
  chipBalance: number        // チップ収支（plusChips + minusChips）
}

/**
 * 分析統計（統合型）
 */
export interface AnalysisStatistics {
  rank?: RankStatistics      // 着順統計（全体モード時はundefined）
  revenue: RevenueStatistics
  point: PointStatistics
  chip: ChipStatistics
}

// ========================================
// User Functions
// ========================================

/**
 * メインユーザーを取得
 */
export async function getMainUser(): Promise<User | undefined> {
  try {
    logger.debug('メインユーザーを取得開始', { context: 'db-utils.getMainUser' });
    const allUsers = await db.users.toArray();
    const mainUser = allUsers.find(user => user.isMainUser);

    if (mainUser) {
      logger.debug('メインユーザー取得成功', {
        context: 'db-utils.getMainUser',
        data: { userId: mainUser.id }
      });
    } else {
      logger.warn('メインユーザーが見つかりません', { context: 'db-utils.getMainUser' });
    }

    return mainUser;
  } catch (err) {
    const error = new DatabaseError('メインユーザーの取得に失敗しました', {
      originalError: err
    });
    logger.error(error.message, {
      context: 'db-utils.getMainUser',
      error
    });
    throw error;
  }
}

/**
 * 全ユーザーを取得
 */
export async function getAllUsers(): Promise<User[]> {
  return await db.users.toArray();
}

/**
 * 登録ユーザーを取得（アクティブのみ、メインユーザーを除く）
 */
export async function getRegisteredUsers(): Promise<User[]> {
  const allUsers = await db.users.toArray();
  return allUsers.filter(user => !user.isMainUser && !user.isArchived);
}

/**
 * 新規ユーザーを追加
 */
export async function addUser(name: string): Promise<User> {
  // バリデーション
  if (!name.trim()) {
    const error = new ValidationError('ユーザー名が空です', 'name');
    logger.error(error.message, {
      context: 'db-utils.addUser',
      error
    });
    throw error;
  }

  try {
    logger.debug('ユーザー追加開始', {
      context: 'db-utils.addUser',
      data: { userName: name }
    });

    const user: User = {
      id: crypto.randomUUID(),
      name,
      isMainUser: false,
      isArchived: false,
      createdAt: new Date()
    };

    await db.users.add(user);

    logger.info('ユーザー追加成功', {
      context: 'db-utils.addUser',
      data: { userId: user.id, userName: user.name }
    });

    return user;
  } catch (err) {
    const error = new DatabaseError('ユーザーの追加に失敗しました', {
      userName: name,
      originalError: err
    });
    logger.error(error.message, {
      context: 'db-utils.addUser',
      error
    });
    throw error;
  }
}

/**
 * ユーザー名を更新
 */
export async function updateUser(userId: string, name: string): Promise<User> {
  // バリデーション
  if (!name.trim()) {
    const error = new ValidationError('ユーザー名が空です', 'name');
    logger.error(error.message, {
      context: 'db-utils.updateUser',
      error
    });
    throw error;
  }

  try {
    logger.debug('ユーザー名更新開始', {
      context: 'db-utils.updateUser',
      data: { userId, newName: name }
    });

    // ユーザー情報を取得
    const user = await db.users.get(userId);
    if (!user) {
      const error = new NotFoundError('ユーザーが見つかりません', userId);
      logger.error(error.message, {
        context: 'db-utils.updateUser',
        error
      });
      throw error;
    }

    // ユーザー名を更新
    await db.users.update(userId, { name: name.trim() });

    // 更新後のユーザー情報を取得
    const updatedUser = await db.users.get(userId);
    if (!updatedUser) {
      throw new DatabaseError('更新後のユーザー情報取得に失敗しました');
    }

    logger.info('ユーザー名更新成功', {
      context: 'db-utils.updateUser',
      data: { userId, oldName: user.name, newName: updatedUser.name }
    });

    return updatedUser;
  } catch (err) {
    if (err instanceof ValidationError || err instanceof NotFoundError) {
      throw err;
    }
    const error = new DatabaseError('ユーザー名の更新に失敗しました', { originalError: err });
    logger.error(error.message, {
      context: 'db-utils.updateUser',
      error
    });
    throw error;
  }
}

/**
 * ユーザーをアーカイブ（論理削除）
 * @param userId - アーカイブするユーザーID
 */
export async function archiveUser(userId: string): Promise<void> {
  try {
    logger.debug('ユーザーアーカイブ開始', {
      context: 'db-utils.archiveUser',
      data: { userId }
    });

    // ユーザー情報を取得
    const user = await db.users.get(userId);
    if (!user) {
      const error = new NotFoundError('ユーザーが見つかりません', userId);
      logger.error(error.message, {
        context: 'db-utils.archiveUser',
        error
      });
      throw error;
    }

    // メインユーザーのアーカイブを防止
    if (user.isMainUser) {
      const error = new ValidationError('メインユーザーはアーカイブできません', 'userId');
      logger.error(error.message, {
        context: 'db-utils.archiveUser',
        error,
        data: { userId }
      });
      throw error;
    }

    // アーカイブフラグを設定
    await db.users.update(userId, {
      isArchived: true,
      archivedAt: new Date()
    });

    logger.info('ユーザーアーカイブ成功', {
      context: 'db-utils.archiveUser',
      data: { userId, userName: user.name }
    });
  } catch (err) {
    if (err instanceof ValidationError || err instanceof NotFoundError) {
      throw err;
    }
    const error = new DatabaseError('ユーザーのアーカイブに失敗しました', { originalError: err });
    logger.error(error.message, {
      context: 'db-utils.archiveUser',
      error
    });
    throw error;
  }
}

/**
 * アーカイブ済みユーザーを復元
 * @param userId - 復元するユーザーID
 */
export async function restoreUser(userId: string): Promise<void> {
  try {
    logger.debug('ユーザー復元開始', {
      context: 'db-utils.restoreUser',
      data: { userId }
    });

    const user = await db.users.get(userId);
    if (!user) {
      const error = new NotFoundError('ユーザーが見つかりません', userId);
      logger.error(error.message, {
        context: 'db-utils.restoreUser',
        error
      });
      throw error;
    }

    if (!user.isArchived) {
      const error = new ValidationError('ユーザーは既にアクティブです', 'userId');
      logger.error(error.message, {
        context: 'db-utils.restoreUser',
        error,
        data: { userId }
      });
      throw error;
    }

    await db.users.update(userId, {
      isArchived: false,
      archivedAt: undefined
    });

    logger.info('ユーザー復元成功', {
      context: 'db-utils.restoreUser',
      data: { userId, userName: user.name }
    });
  } catch (err) {
    if (err instanceof ValidationError || err instanceof NotFoundError) {
      throw err;
    }
    const error = new DatabaseError('ユーザーの復元に失敗しました', { originalError: err });
    logger.error(error.message, {
      context: 'db-utils.restoreUser',
      error
    });
    throw error;
  }
}

/**
 * アクティブユーザーのみ取得
 */
export async function getActiveUsers(): Promise<User[]> {
  try {
    const allUsers = await db.users.toArray();
    return allUsers.filter(u => !u.isArchived);
  } catch (err) {
    const error = new DatabaseError('アクティブユーザーの取得に失敗しました', {
      originalError: err
    });
    logger.error(error.message, {
      context: 'db-utils.getActiveUsers',
      error
    });
    throw error;
  }
}

/**
 * アーカイブ済みユーザーのみ取得
 */
export async function getArchivedUsers(): Promise<User[]> {
  try {
    const allUsers = await db.users.toArray();
    return allUsers.filter(u => u.isArchived);
  } catch (err) {
    const error = new DatabaseError('アーカイブ済みユーザーの取得に失敗しました', {
      originalError: err
    });
    logger.error(error.message, {
      context: 'db-utils.getArchivedUsers',
      error
    });
    throw error;
  }
}

/**
 * @deprecated archiveUserを使用してください
 * ユーザーを削除（非推奨）
 */
export async function deleteUser(userId: string): Promise<void> {
  logger.warn('deleteUserは非推奨です。archiveUserを使用してください', {
    context: 'db-utils.deleteUser',
    data: { userId }
  });

  // 内部的にarchiveUserを呼び出す
  return archiveUser(userId);
}

// ========================================
// Session Functions
// ========================================

/**
 * 新規セッションを作成
 */
export async function createSession(
  date: string,
  mode: '4-player' | '3-player'
): Promise<Session> {
  const session: Session = {
    id: crypto.randomUUID(),
    date,
    mode,
    rate: 30,           // デフォルト値
    umaValue: 10,       // デフォルト値
    chipRate: 100,      // デフォルト値
    parlorFee: 0,       // デフォルト値
    umaRule: 'standard', // デフォルト値
    createdAt: new Date(),
    updatedAt: new Date()
  };

  await db.sessions.add(session);
  return session;
}

/**
 * 日付でセッションを取得
 */
export async function getSessionsByDate(date: string): Promise<Session[]> {
  return await db.sessions
    .where('date')
    .equals(date)
    .toArray();
}

/**
 * すべてのセッションを取得（日付降順）
 */
export async function getAllSessions(): Promise<Session[]> {
  return await db.sessions
    .orderBy('date')
    .reverse()
    .toArray();
}

// ========================================
// Hanchan Functions
// ========================================

/**
 * 新規半荘を作成
 */
export async function createHanchan(
  sessionId: string,
  hanchanNumber: number
): Promise<Hanchan> {
  const hanchan: Hanchan = {
    id: crypto.randomUUID(),
    sessionId,
    hanchanNumber,
    autoCalculated: false,
    createdAt: new Date()
  };

  await db.hanchans.add(hanchan);
  return hanchan;
}

/**
 * セッションの半荘を取得
 */
export async function getHanchansBySession(sessionId: string): Promise<Hanchan[]> {
  return await db.hanchans
    .where('sessionId')
    .equals(sessionId)
    .sortBy('hanchanNumber');
}

// ========================================
// PlayerResult Functions
// ========================================

/**
 * プレイヤー結果を作成
 */
export async function createPlayerResult(
  hanchanId: string,
  userId: string | null,
  playerName: string,
  score: number,
  umaMark: UmaMark,
  position = 0  // デフォルト値: 0
): Promise<PlayerResult> {
  const playerResult: PlayerResult = {
    id: crypto.randomUUID(),
    hanchanId,
    userId,
    playerName,
    score,
    umaMark,
    isSpectator: false,
    chips: 0,
    position,
    createdAt: new Date()
  };

  await db.playerResults.add(playerResult);
  return playerResult;
}

/**
 * 半荘のプレイヤー結果を取得（position順にソート）
 */
export async function getPlayerResultsByHanchan(hanchanId: string): Promise<PlayerResult[]> {
  const results = await db.playerResults
    .where('hanchanId')
    .equals(hanchanId)
    .toArray();

  // positionでソート（0, 1, 2, 3の順）- InputTabでの列順を復元
  return results.sort((a, b) => a.position - b.position);
}

// ========================================
// Validation Functions
// ========================================

/**
 * ゼロサム原則を検証
 */
export async function validateZeroSum(hanchanId: string): Promise<boolean> {
  const playerResults = await db.playerResults
    .where('hanchanId')
    .equals(hanchanId)
    .filter(pr => !pr.isSpectator) // 見学者を除く
    .toArray();

  const total = playerResults.reduce((sum, pr) => sum + pr.score, 0);

  return Math.abs(total) < 0.01; // 誤差許容
}

/**
 * ウママークの合計を検証（ゼロサムであるべき）
 */
export async function validateUmaMarks(hanchanId: string): Promise<boolean> {
  const playerResults = await db.playerResults
    .where('hanchanId')
    .equals(hanchanId)
    .filter(pr => !pr.isSpectator) // 見学者を除く
    .toArray();

  const total = playerResults.reduce(
    (sum, pr) => sum + umaMarkToValue(pr.umaMark),
    0
  );

  return total === 0; // 必ず0になる（ゼロサム）
}

// ========================================
// Complex Query Functions
// ========================================

/**
 * セッションの全データを取得（半荘・プレイヤー結果含む）
 */
export async function getSessionWithDetails(sessionId: string) {
  const session = await db.sessions.get(sessionId);

  if (!session) {
    return null;
  }

  const hanchans = await getHanchansBySession(sessionId);

  const hanchansWithPlayers = await Promise.all(
    hanchans.map(async (hanchan) => ({
      ...hanchan,
      players: await getPlayerResultsByHanchan(hanchan.id)
    }))
  );

  return {
    session,
    hanchans: hanchansWithPlayers
  };
}

/**
 * 特定ユーザーの全統計データを取得
 */
export async function getUserStats(userId: string) {
  // ユーザーが参加した全てのPlayerResult
  const playerResults = await db.playerResults
    .where('userId')
    .equals(userId)
    .toArray();

  // 各PlayerResultから半荘情報を取得
  const hanchanIds = [...new Set(playerResults.map(pr => pr.hanchanId))];
  const hanchans = await db.hanchans
    .where('id')
    .anyOf(hanchanIds)
    .toArray();

  // セッション情報を取得
  const sessionIds = [...new Set(hanchans.map(h => h.sessionId))];
  const sessions = await db.sessions
    .where('id')
    .anyOf(sessionIds)
    .toArray();

  return { playerResults, hanchans, sessions };
}

// ========================================
// Data Conversion Functions (UI ↔ DB)
// ========================================

/**
 * DB Session → UI SessionSettings
 * 編集モード開始時に使用
 */
export function sessionToSettings(session: Session): SessionSettings {
  return {
    date: session.date,
    rate: session.rate,
    umaValue: session.umaValue,
    chipRate: session.chipRate,
    umaRule: session.umaRule
  }
}

/**
 * DB Hanchan[] → UI Hanchan[]
 * 編集モード開始時に使用
 * - players配列をposition順にソート
 * - umaMarkManualをfalseで初期化（編集時はリセット）
 */
export function dbHanchansToUIHanchans(
  dbHanchans: Array<Hanchan & { players: PlayerResult[] }>
): UIHanchan[] {
  return dbHanchans.map(hanchan => ({
    hanchanNumber: hanchan.hanchanNumber,
    autoCalculated: false, // 編集時はリセット
    players: hanchan.players
      .sort((a, b) => a.position - b.position) // position順にソート
      .map(player => ({
        playerName: player.playerName,
        userId: player.userId,
        score: player.score,
        umaMark: player.umaMark,
        chips: player.chips,
        parlorFee: 0, // UI層で設定（DBにはこのフィールドなし）
        isSpectator: player.isSpectator,
        umaMarkManual: false // 編集時はリセット
      }))
  }))
}

/**
 * UI編集データ → DB保存用データ
 * 保存時に使用
 * - GameMode文字列変換: '4-player' → 'four-player'
 * - position番号を配列インデックスから付与
 * - score ?? 0変換
 */
export function uiDataToSaveData(
  settings: SessionSettings,
  hanchans: UIHanchan[],
  mode: GameMode
): SessionSaveData {
  return {
    date: settings.date,
    mode: mode === '4-player' ? 'four-player' : 'three-player',
    rate: settings.rate,
    umaValue: settings.umaValue,
    chipRate: settings.chipRate,
    umaRule: settings.umaRule,
    hanchans: hanchans.map(hanchan => ({
      hanchanNumber: hanchan.hanchanNumber,
      players: hanchan.players.map((player, idx) => ({
        playerName: player.playerName,
        userId: player.userId,
        score: player.score ?? 0,
        umaMark: player.umaMark,
        chips: player.chips,
        parlorFee: player.parlorFee,
        isSpectator: player.isSpectator,
        position: idx  // 配列インデックスをposition番号として使用
      }))
    }))
  }
}

// ========================================
// Session Save Functions
// ========================================

/**
 * セッション保存用のデータ型
 */
export interface SessionSaveData {
  date: string
  mode: 'four-player' | 'three-player'
  rate: number
  umaValue: number
  chipRate: number
  umaRule: 'standard' | 'second-minus'
  hanchans: Array<{
    hanchanNumber: number
    players: Array<{
      playerName: string
      userId: string | null
      score: number
      umaMark: UmaMark
      chips: number
      parlorFee: number
      isSpectator: boolean
      position: number  // 列番号（0, 1, 2, 3）
    }>
  }>
}

/**
 * 空ハンチャン判定
 *
 * 空ハンチャンの定義:
 * - 全プレイヤーが見学者、または
 * - 全プレイヤーのscoreがnullまたは0
 *
 * @param hanchan - 判定対象のハンチャンデータ
 * @returns true: 空ハンチャン, false: 有効なハンチャン
 *
 * @example
 * // 全員0点
 * isEmptyHanchan({ players: [{ score: 0, isSpectator: false }, { score: 0, isSpectator: false }] }) // true
 *
 * // 1人でも点数入力あり
 * isEmptyHanchan({ players: [{ score: 100, isSpectator: false }, { score: 0, isSpectator: false }] }) // false
 *
 * // 全員見学者
 * isEmptyHanchan({ players: [{ isSpectator: true }, { isSpectator: true }] }) // true
 */
function isEmptyHanchan(hanchan: { players: Array<{ score: number | null; isSpectator: boolean }> }): boolean {
  return hanchan.players.every(p =>
    p.isSpectator || p.score === null || p.score === 0
  )
}

/**
 * セッションを保存（Session + Hanchan + PlayerResult を一括作成）
 */
export async function saveSession(data: SessionSaveData): Promise<string> {
  try {
    logger.info('セッション保存開始', {
      context: 'db-utils.saveSession',
      data: { date: data.date, mode: data.mode }
    });

    // バリデーション
    if (!data.date || !data.mode) {
      throw new ValidationError('必須項目が入力されていません', 'date, mode');
    }

    if (data.hanchans.length === 0) {
      throw new ValidationError('半荘データがありません', 'hanchans');
    }

    // 空ハンチャンの二重チェック（防御的プログラミング）
    const validHanchans = data.hanchans.filter(h => !isEmptyHanchan(h))

    if (validHanchans.length === 0) {
      logger.warn('全ハンチャンが空データでした', {
        context: 'db-utils.saveSession',
        data: { totalHanchans: data.hanchans.length }
      })
      throw new ValidationError('有効な半荘データがありません', 'hanchans')
    }

    if (validHanchans.length < data.hanchans.length) {
      logger.warn('空ハンチャンが検出されました（フィルタリング済み）', {
        context: 'db-utils.saveSession',
        data: {
          totalHanchans: data.hanchans.length,
          validHanchans: validHanchans.length,
          filtered: data.hanchans.length - validHanchans.length
        }
      })
    }

    // 有効ハンチャンのみを保存
    const dataToSave = { ...data, hanchans: validHanchans }

    // Session作成
    const sessionId = crypto.randomUUID();
    const now = new Date();

    const session: Session = {
      id: sessionId,
      date: dataToSave.date,
      mode: dataToSave.mode === 'four-player' ? '4-player' : '3-player',
      rate: dataToSave.rate,
      umaValue: dataToSave.umaValue,
      chipRate: dataToSave.chipRate,
      parlorFee: dataToSave.hanchans[0]?.players[0]?.parlorFee || 0,
      umaRule: dataToSave.umaRule as 'standard' | 'second-minus',
      createdAt: now,
      updatedAt: now
    };

    // トランザクション内で全て保存（完了まで他の処理から見えない）
    await db.transaction('rw', [db.sessions, db.hanchans, db.playerResults], async () => {
      await db.sessions.add(session);

      // 各半荘とプレイヤー結果を作成（有効ハンチャンのみ）
      for (const hanchanData of dataToSave.hanchans) {
        const hanchanId = crypto.randomUUID();

        logger.debug('半荘保存開始', {
          context: 'db-utils.saveSession',
          data: { hanchanNumber: hanchanData.hanchanNumber }
        });

        const hanchan: Hanchan = {
          id: hanchanId,
          sessionId,
          hanchanNumber: hanchanData.hanchanNumber,
          autoCalculated: false,
          createdAt: now
        };

        await db.hanchans.add(hanchan);
        logger.debug('Hanchanレコード保存完了', {
          context: 'db-utils.saveSession',
          data: { hanchanNumber: hanchanData.hanchanNumber }
        });

        // プレイヤー結果を作成
        for (const playerData of hanchanData.players) {
          const playerResult: PlayerResult = {
            id: crypto.randomUUID(),
            hanchanId,
            userId: playerData.userId,
            playerName: playerData.playerName,
            score: playerData.score,
            umaMark: playerData.umaMark,
            isSpectator: playerData.isSpectator,
            chips: playerData.chips,
            position: playerData.position,  // 列番号を保存
            createdAt: now
          };

          await db.playerResults.add(playerResult);
        }
        logger.debug('PlayerResults保存完了', {
          context: 'db-utils.saveSession',
          data: {
            hanchanNumber: hanchanData.hanchanNumber,
            playerCount: hanchanData.players.length
          }
        });

        // ゼロサム検証
        const isZeroSum = await validateZeroSum(hanchanId);
        logger.debug('ゼロサム検証完了', {
          context: 'db-utils.saveSession',
          data: {
            hanchanNumber: hanchanData.hanchanNumber,
            isValid: isZeroSum
          }
        });
        if (!isZeroSum) {
          logger.warn(`半荘${hanchanData.hanchanNumber}のゼロサムチェック失敗`, {
            context: 'db-utils.saveSession',
            data: { hanchanId, hanchanNumber: hanchanData.hanchanNumber }
          });
        }

        // ウママーク合計検証
        const isUmaValid = await validateUmaMarks(hanchanId);
        logger.debug('ウママーク検証完了', {
          context: 'db-utils.saveSession',
          data: {
            hanchanNumber: hanchanData.hanchanNumber,
            isValid: isUmaValid
          }
        });
        if (!isUmaValid) {
          logger.warn(`半荘${hanchanData.hanchanNumber}のウママーク合計チェック失敗`, {
            context: 'db-utils.saveSession',
            data: { hanchanId, hanchanNumber: hanchanData.hanchanNumber }
          });
        }

        logger.debug('半荘保存完了', {
          context: 'db-utils.saveSession',
          data: { hanchanNumber: hanchanData.hanchanNumber }
        });
      }
    }); // トランザクション終了

    logger.info('セッション保存成功', {
      context: 'db-utils.saveSession',
      data: { sessionId, hanchanCount: dataToSave.hanchans.length }
    });

    return sessionId;
  } catch (err) {
    const error = new DatabaseError('セッションの保存に失敗しました', {
      originalError: err
    });
    logger.error(error.message, {
      context: 'db-utils.saveSession',
      error
    });
    throw error;
  }
}

/**
 * セッションを削除（カスケード削除: Session → Hanchan → PlayerResult）
 * @param sessionId セッションID
 */
export async function deleteSession(sessionId: string): Promise<void> {
  try {
    logger.info('セッション削除開始', {
      context: 'db-utils.deleteSession',
      data: { sessionId }
    });

    // Dexieのtransactionで原子性を保証
    await db.transaction('rw', [db.sessions, db.hanchans, db.playerResults], async () => {
      // 1. 関連する半荘を取得
      const hanchans = await db.hanchans
        .where('sessionId')
        .equals(sessionId)
        .toArray();

      // 2. 各半荘のPlayerResultを削除
      for (const hanchan of hanchans) {
        await db.playerResults
          .where('hanchanId')
          .equals(hanchan.id)
          .delete();
      }

      // 3. 半荘を削除
      await db.hanchans
        .where('sessionId')
        .equals(sessionId)
        .delete();

      // 4. セッションを削除
      await db.sessions.delete(sessionId);
    });

    logger.info('セッション削除成功', {
      context: 'db-utils.deleteSession',
      data: { sessionId }
    });
  } catch (err) {
    const error = new DatabaseError('セッションの削除に失敗しました', {
      originalError: err
    });
    logger.error(error.message, {
      context: 'db-utils.deleteSession',
      error
    });
    throw error;
  }
}

/**
 * セッションを更新（カスケード削除+再作成パターン）
 * トランザクション内で以下を実行:
 * 1. 既存の半荘・プレイヤー結果を削除
 * 2. セッション設定を更新
 * 3. 新しい半荘・プレイヤー結果を作成
 * 4. サマリーを再計算・保存
 *
 * @param sessionId 更新対象のセッションID
 * @param data 更新データ
 * @param mainUserId メインユーザーID（サマリー計算用）
 */
export async function updateSession(
  sessionId: string,
  data: SessionSaveData,
  mainUserId: string
): Promise<void> {
  try {
    logger.info('セッション更新開始', {
      context: 'db-utils.updateSession',
      data: { sessionId, date: data.date, mode: data.mode }
    });

    // バリデーション
    if (!data.date || !data.mode) {
      throw new ValidationError('必須項目が入力されていません', 'date, mode');
    }

    if (data.hanchans.length === 0) {
      throw new ValidationError('半荘データがありません', 'hanchans');
    }

    // Dexieのtransactionで原子性を保証（全て成功 or 全て失敗）
    await db.transaction('rw', [db.sessions, db.hanchans, db.playerResults], async () => {
      // 1. 既存の半荘IDを取得
      const existingHanchans = await db.hanchans
        .where('sessionId')
        .equals(sessionId)
        .toArray();

      logger.debug('既存半荘取得完了', {
        context: 'db-utils.updateSession',
        data: { count: existingHanchans.length }
      });

      // 2. カスケード削除: PlayerResults → Hanchans
      for (const hanchan of existingHanchans) {
        await db.playerResults
          .where('hanchanId')
          .equals(hanchan.id)
          .delete();
      }

      await db.hanchans
        .where('sessionId')
        .equals(sessionId)
        .delete();

      logger.debug('既存データ削除完了', {
        context: 'db-utils.updateSession'
      });

      // 3. セッション設定を更新
      const now = new Date();
      await db.sessions.update(sessionId, {
        date: data.date,
        mode: data.mode === 'four-player' ? '4-player' : '3-player',
        rate: data.rate,
        umaValue: data.umaValue,
        chipRate: data.chipRate,
        parlorFee: data.hanchans[0]?.players[0]?.parlorFee || 0,
        umaRule: data.umaRule as 'standard' | 'second-minus',
        updatedAt: now
      });

      logger.debug('セッション設定更新完了', {
        context: 'db-utils.updateSession'
      });

      // 4. 新しい半荘とプレイヤー結果を作成
      for (const hanchanData of data.hanchans) {
        const hanchanId = crypto.randomUUID();

        logger.debug('半荘作成開始', {
          context: 'db-utils.updateSession',
          data: { hanchanNumber: hanchanData.hanchanNumber }
        });

        const hanchan: Hanchan = {
          id: hanchanId,
          sessionId,
          hanchanNumber: hanchanData.hanchanNumber,
          autoCalculated: false,
          createdAt: now
        };

        await db.hanchans.add(hanchan);

        // プレイヤー結果を作成
        for (const playerData of hanchanData.players) {
          const playerResult: PlayerResult = {
            id: crypto.randomUUID(),
            hanchanId,
            userId: playerData.userId,
            playerName: playerData.playerName,
            score: playerData.score,
            umaMark: playerData.umaMark,
            isSpectator: playerData.isSpectator,
            chips: playerData.chips,
            position: playerData.position,
            createdAt: now
          };

          await db.playerResults.add(playerResult);
        }

        logger.debug('半荘作成完了', {
          context: 'db-utils.updateSession',
          data: { hanchanNumber: hanchanData.hanchanNumber }
        });

        // ゼロサム検証
        const isZeroSum = await validateZeroSum(hanchanId);
        if (!isZeroSum) {
          logger.warn(`半荘${hanchanData.hanchanNumber}のゼロサムチェック失敗`, {
            context: 'db-utils.updateSession',
            data: { hanchanId, hanchanNumber: hanchanData.hanchanNumber }
          });
        }

        // ウママーク合計検証
        const isUmaValid = await validateUmaMarks(hanchanId);
        if (!isUmaValid) {
          logger.warn(`半荘${hanchanData.hanchanNumber}のウママーク合計チェック失敗`, {
            context: 'db-utils.updateSession',
            data: { hanchanId, hanchanNumber: hanchanData.hanchanNumber }
          });
        }
      }
    }); // トランザクション終了

    logger.debug('トランザクション完了', {
      context: 'db-utils.updateSession'
    });

    // 5. サマリーを再計算（トランザクション外で実行）
    // session-utils.tsのcalculateSessionSummaryを使用
    const { calculateSessionSummary } = await import('./session-utils');
    const summary = await calculateSessionSummary(sessionId, mainUserId);

    // 6. サマリーを保存
    await db.sessions.update(sessionId, { summary });

    logger.info('セッション更新成功', {
      context: 'db-utils.updateSession',
      data: { sessionId, hanchanCount: data.hanchans.length }
    });
  } catch (err) {
    const error = new DatabaseError('セッションの更新に失敗しました', {
      originalError: err
    });
    logger.error(error.message, {
      context: 'db-utils.updateSession',
      error
    });
    throw error;
  }
}

// ========================================
// Analysis Functions (Phase 5: 分析タブ用)
// ========================================

/**
 * 半荘内のプレイヤーの着順を計算（点数ベース）
 * session-utils.ts の calculateRanks と同じロジック
 */
function calculateRanksFromScores(playerResults: PlayerResult[]): Map<string, number> {
  const rankMap = new Map<string, number>()

  // 見学者を除外、かつ点数が入力されているプレイヤーのみを対象
  const activePlayers = playerResults
    .filter((p) => !p.isSpectator && p.score !== null)
    .sort((a, b) => b.score! - a.score!) // 点数降順

  // 着順を割り当て（同点の場合は同着）
  let currentRank = 1
  activePlayers.forEach((player, index) => {
    if (index > 0 && player.score! < activePlayers[index - 1].score!) {
      currentRank = index + 1
    }
    rankMap.set(player.id, currentRank)
  })

  return rankMap
}

/**
 * 着順統計を計算
 *
 * @param hanchans 半荘データ配列（各半荘の全プレイヤーデータを含む）
 * @param targetUserId 対象ユーザーID
 * @param mode ゲームモード
 * @returns 着順統計
 */
export function calculateRankStatistics(
  hanchans: Array<{ players: PlayerResult[] }>,
  targetUserId: string,
  mode: '4-player' | '3-player'
): RankStatistics {
  const rankCounts = { first: 0, second: 0, third: 0, fourth: 0 }
  let totalGames = 0

  // 各半荘ごとに着順を計算
  for (const hanchan of hanchans) {
    // 防御的プログラミング: 空ハンチャンをスキップ（全員0点の場合）
    const hasValidScores = hanchan.players.some(p =>
      !p.isSpectator && p.score !== null && p.score !== 0
    )

    if (!hasValidScores) {
      continue // 全員0点 or null の場合はスキップ
    }

    // 半荘内の全プレイヤーの着順を計算（点数順）
    const ranks = calculateRanksFromScores(hanchan.players)

    // 対象ユーザーのPlayerResultを見つける
    const targetPlayer = hanchan.players.find(p => p.userId === targetUserId)
    if (!targetPlayer || targetPlayer.isSpectator || targetPlayer.score === null || targetPlayer.score === 0) {
      continue // 見学者 or 点数未入力 or 0点 はスキップ
    }

    // 対象ユーザーの着順を取得
    const rank = ranks.get(targetPlayer.id)
    if (!rank) continue

    // 着順をカウント
    totalGames++
    switch (rank) {
      case 1: rankCounts.first++; break
      case 2: rankCounts.second++; break
      case 3: rankCounts.third++; break
      case 4: rankCounts.fourth++; break
    }
  }

  if (totalGames === 0) {
    return {
      totalGames: 0,
      rankCounts: { first: 0, second: 0, third: 0, fourth: mode === '4-player' ? 0 : undefined },
      rankRates: { first: 0, second: 0, third: 0, fourth: mode === '4-player' ? 0 : undefined },
      averageRank: 0
    }
  }

  // 着順率計算
  const rankRates = {
    first: (rankCounts.first / totalGames) * 100,
    second: (rankCounts.second / totalGames) * 100,
    third: (rankCounts.third / totalGames) * 100,
    fourth: mode === '4-player' ? (rankCounts.fourth / totalGames) * 100 : undefined
  }

  // 平均着順計算
  const totalRankSum =
    1 * rankCounts.first +
    2 * rankCounts.second +
    3 * rankCounts.third +
    (mode === '4-player' ? 4 * rankCounts.fourth : 0)
  const averageRank = totalRankSum / totalGames

  return {
    totalGames,
    rankCounts: mode === '4-player' ? rankCounts : { ...rankCounts, fourth: undefined },
    rankRates,
    averageRank: Number(averageRank.toFixed(2))
  }
}

/**
 * 収支統計を計算
 */
export function calculateRevenueStatistics(
  sessions: Array<{ totalPayout: number }>
): RevenueStatistics {
  let totalIncome = 0
  let totalExpense = 0

  sessions.forEach(session => {
    if (session.totalPayout > 0) {
      totalIncome += session.totalPayout
    } else {
      totalExpense += session.totalPayout // 負の値
    }
  })

  return {
    totalIncome,
    totalExpense,
    totalBalance: totalIncome + totalExpense
  }
}

/**
 * ポイント統計を計算
 */
export function calculatePointStatistics(
  playerResults: PlayerResult[]
): PointStatistics {
  // 見学者を除外、かつscore !== null && score !== 0のみ対象（防御的プログラミング）
  const activeResults = playerResults.filter(pr =>
    !pr.isSpectator && pr.score !== null && pr.score !== 0
  )

  let plusPoints = 0
  let minusPoints = 0

  activeResults.forEach(pr => {
    const score = pr.score!  // filterで null と 0 は除外済み
    if (score > 0) {
      plusPoints += score
    } else {
      minusPoints += score // 負の値
    }
  })

  return {
    plusPoints,
    minusPoints,
    pointBalance: plusPoints + minusPoints
  }
}

/**
 * チップ統計を計算
 */
export function calculateChipStatistics(
  playerResults: PlayerResult[]
): ChipStatistics {
  let plusChips = 0
  let minusChips = 0

  playerResults.forEach(pr => {
    if (pr.chips > 0) {
      plusChips += pr.chips
    } else if (pr.chips < 0) {
      minusChips += pr.chips
    }
  })

  return {
    plusChips,
    minusChips,
    chipBalance: plusChips + minusChips
  }
}

// ========================================
// Filter Functions (Phase 5-2: フィルター機能)
// ========================================

/**
 * 期間でセッションをフィルター
 */
export function filterSessionsByPeriod<T extends { session: { date: string } }>(
  sessions: T[],
  period: PeriodType
): T[] {
  const now = new Date()
  const currentYear = now.getFullYear()
  const currentMonth = now.getMonth() + 1 // 1-12

  switch (period) {
    case 'this-month': {
      const targetYearMonth = `${currentYear}-${String(currentMonth).padStart(2, '0')}`
      return sessions.filter(s => s.session.date.startsWith(targetYearMonth))
    }
    case 'this-year': {
      const targetYear = `${currentYear}`
      return sessions.filter(s => s.session.date.startsWith(targetYear))
    }
    case 'all-time': {
      return sessions
    }
    default: {
      // 'year-YYYY' 形式
      if (period.startsWith('year-')) {
        const year = period.substring(5) // 'year-2024' → '2024'
        return sessions.filter(s => s.session.date.startsWith(year))
      }
      return sessions
    }
  }
}

/**
 * モードでセッションをフィルター
 */
export function filterSessionsByMode<T extends { session: { mode: GameMode } }>(
  sessions: T[],
  mode: GameMode | 'all'
): T[] {
  if (mode === 'all') {
    return sessions
  }
  return sessions.filter(s => s.session.mode === mode)
}
