# プロジェクト内リファクタリングパターン

## 成功したパターン

### 1. 大規模コンポーネント分割パターン

**適用例**: InputTab.tsx (752行 → 255行)

**手順**:
1. ビジネスロジックを`lib/`に抽出
2. UIを責任ごとに分割（設定、入力、集計）
3. 型定義を共有可能な形で再構成
4. 重複コードを統合

**ディレクトリ構造**:
```
src/
├── components/
│   ├── [feature]/          # 機能別サブコンポーネント
│   │   ├── Settings.tsx    # 設定UI
│   │   ├── InputTable.tsx  # 入力UI
│   │   └── Summary.tsx     # 集計UI
│   └── tabs/
│       └── FeatureTab.tsx  # メインコンポーネント
└── lib/
    └── feature-utils.ts    # ビジネスロジック
```

**命名規則**:
- サブコンポーネント: `[機能名][役割].tsx`
- ユーティリティ: `[機能名]-utils.ts`
- 型定義: 親コンポーネントから`export type`で共有

### 2. 重複ロジック統合パターン

**適用例**: `umaMarkToValue()` 3箇所 → 1箇所

**手順**:
1. 重複箇所を特定（grep/analyzeツール活用）
2. 最も汎用的な実装を選択
3. `lib/`に移動して`export`
4. 各使用箇所でインポートに置き換え

**確認方法**:
```bash
# 重複検出
grep -r "function umaMarkToValue" src/

# 置き換え後確認
grep -r "umaMarkToValue" src/ | grep -v "export"
```

## アンチパターン（避けるべき）

### ❌ 過度な抽象化
- 1回しか使わないロジックを無理に共通化
- 3ファイル以上で使用される場合のみ抽出

### ❌ 不完全な分割
- 状態管理が複数コンポーネントに分散
- 1つのコンポーネントが複数の責任を持つ

### ❌ 型定義の散逸
- 同じ型を複数箇所で再定義
- 共有型は親か`lib/types.ts`に集約

## このプロジェクトの設計原則

### 型の優先順位
1. **DB型** (`lib/db.ts`) - データベーススキーマ由来
2. **UI型** (コンポーネント内) - コンポーネント固有の状態
3. **共有型** (`lib/types.ts`) - 複数箇所で使用

### コンポーネント設計
- **200行以下**: 理想的なサイズ
- **300行**: 分割検討の目安
- **500行超**: 即座に分割必須

### ファイル配置
- **1機能 = 1ディレクトリ**: `components/[feature]/`
- **共通UI**: `components/ui/` (shadcn/ui)
- **ビジネスロジック**: `lib/[feature]-utils.ts`

## 参考: 既存の良い設計例

### ユーザーアーカイブシステム (Phase 2.5)
- `useUsers.ts`: ロジックとDB操作を集約
- `SettingsTab.tsx`: UIのみに専念
- アーカイブ/復元機能が明確に分離

### セッションサマリー最適化 (Phase 4 Stage 3)
- `session-utils.ts`: 計算ロジック
- `useSessions.ts`: データ取得+キャッシュ
- `HistoryTab.tsx`: 表示のみ

## 今後の適用候補

### 1. HistoryTab.tsx (184行)
- まだ分割不要（200行未満）
- 機能追加時に検討

### 2. SessionDetailDialog.tsx (165行)
- まだ分割不要
- 編集機能追加時に分割検討

### 3. AnalysisTab.tsx (未実装)
- 実装時から分割前提で設計
- グラフ・統計・フィルター等で分割
